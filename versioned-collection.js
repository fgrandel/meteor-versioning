// Generated by CoffeeScript 1.4.0
(function() {
  var OriginalCollection, OriginalLivedataSubscription,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  OriginalCollection = Meteor.Collection;

  Meteor.Collection = (function(_super) {

    __extends(Collection, _super);

    Collection.prototype._versioned = false;

    function Collection(name, options) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      Collection.__super__.constructor.call(this, name, options);
      this._versioned = options.versioned != null ? options.versioned : false;
      if (!this._versioned) {
        return this;
      }
      this._defineOperations();
      this._crdts = new OriginalCollection("_" + name + "Crdts", {
        _preventAutopublish: true
      });
      if (Meteor.isServer) {
        this._crdts._ensureIndex({
          crdtId: 1
        });
      }
      this._propSpec = options.props != null ? options.props : {};
      _.each(['insert', 'update', 'remove', 'allow', 'deny'], function(method) {
        _this["_" + method] = _this[method];
        return delete _this[method];
      });
      this._tx = Meteor.tx;
      this._tx._addCollection(this);
      this._crdts.find().observe({
        removed: function(old) {
          return Meteor.tx._purgeUndoRedo();
        }
      });
    }

    Collection.prototype.insertOne = function(object) {
      var id;
      if (object._id != null) {
        id = object._id;
        delete object._id;
      } else {
        id = this._makeNewID();
      }
      this._tx._addOperation({
        op: 'insertObject',
        collection: this._name,
        crdtId: id,
        args: {
          object: object,
          id: this._makeNewID()
        }
      });
      return id;
    };

    Collection.prototype.removeOne = function(id) {
      this._tx._addOperation({
        op: 'removeObject',
        collection: this._name,
        crdtId: id
      });
      return id;
    };

    Collection.prototype.setProperty = function(id, key, value) {
      this._tx._addOperation({
        op: 'insertProperty',
        collection: this._name,
        crdtId: id,
        args: {
          key: key,
          value: value
        }
      });
      return id;
    };

    Collection.prototype.unsetProperty = function(id, key, locator) {
      var args;
      if (locator == null) {
        locator = null;
      }
      args = {
        key: key
      };
      if (locator != null) {
        args.locator = locator;
      }
      this._tx._addOperation({
        op: 'removeProperty',
        collection: this._name,
        crdtId: id,
        args: args
      });
      return id;
    };

    Collection.prototype._getCrdt = function(crdtId) {
      var serializedCrdt;
      serializedCrdt = this._crdts.findOne({
        _crdtId: crdtId
      });
      if (serializedCrdt != null) {
        return new Meteor._CrdtDocument(this._propSpec, serializedCrdt);
      } else {
        return void 0;
      }
    };

    Collection.prototype._getCurrentIndex = function(crdt, key) {
      var idxs;
      idxs = Meteor._ensure(this._propertyIdxs, crdt.id);
      if (idxs[key] == null) {
        idxs[key] = crdt.getNextIndex(key);
      }
      return idxs[key];
    };

    Collection.prototype._txRunning = function() {
      return this._updatedCrdts != null;
    };

    Collection.prototype._txStart = function() {
      console.assert(!this._txRunning(), 'Trying to start an already running transaction.');
      this._updatedCrdts = [];
      this._propertyIdxs = {};
      return true;
    };

    Collection.prototype._txCommit = function() {
      var crdt, crdtId, mongoId, newSnapshot, oldSnapshot, serializedCrdt, _i, _len, _ref;
      console.assert(this._txRunning(), 'Trying to commit a non-existent transaction.');
      _ref = this._updatedCrdts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        mongoId = _ref[_i];
        serializedCrdt = this._crdts.findOne({
          _id: mongoId
        });
        console.assert(serializedCrdt != null);
        crdt = new Meteor._CrdtDocument(this._propSpec, serializedCrdt);
        crdtId = crdt.crdtId;
        newSnapshot = crdt.snapshot();
        oldSnapshot = this.findOne({
          _id: crdtId
        });
        if ((newSnapshot != null) && !(oldSnapshot != null)) {
          this._insert(newSnapshot);
        }
        if ((newSnapshot != null) && (oldSnapshot != null)) {
          this._update({
            _id: crdtId
          }, newSnapshot);
        }
        if ((oldSnapshot != null) && !(newSnapshot != null)) {
          this._remove({
            _id: crdtId
          });
        }
      }
      this._updatedCrdts = void 0;
      return true;
    };

    Collection.prototype._txAbort = function() {
      return this._updatedCrdts = void 0;
    };

    Collection.prototype._defineOperations = function() {
      var _this = this;
      return this._ops = {
        insertObject: function(crdtId, args, clock, site) {
          var crdt, entry, index, key, mongoId, serializedCrdt, value, _i, _len, _ref;
          console.assert(_this._txRunning(), 'Trying to execute operation "insertObject" outside a transaction.');
          crdt = _this._getCrdt(crdtId);
          if (crdt != null) {
            if (!crdt.deleted) {
              Meteor.log["throw"]('crdt.tryingToUndeleteVisibleCrdt', {
                collection: _this._name,
                crdtId: crdtId
              });
            }
            _this._crdts.update({
              _id: crdt.id
            }, {
              $set: {
                _deleted: false,
                _clock: clock
              }
            });
            mongoId = crdt.id;
          } else {
            crdt = new Meteor._CrdtDocument(_this._propSpec);
            crdt.id = args.id;
            crdt.crdtId = crdtId;
            crdt.clock = clock;
            _ref = args.object;
            for (key in _ref) {
              value = _ref[key];
              index = _this._getCurrentIndex(crdt, key);
              if (_.isArray(value)) {
                for (_i = 0, _len = value.length; _i < _len; _i++) {
                  entry = value[_i];
                  crdt.insertAtIndex(key, entry, index, site);
                }
              } else {
                crdt.insertAtIndex(key, value, index, site);
              }
            }
            serializedCrdt = crdt.serialize();
            mongoId = _this._crdts.insert(serializedCrdt);
          }
          _this._updatedCrdts.push(mongoId);
          return crdtId;
        },
        removeObject: function(crdtId, args, clock, site) {
          var crdt;
          console.assert(_this._txRunning(), 'Trying to execute operation "removeObject" outside a transaction.');
          crdt = _this._getCrdt(crdtId);
          if (crdt == null) {
            Meteor.log["throw"]('crdt.tryingToDeleteNonexistentCrdt', {
              collection: _this._name,
              crdtId: crdtId
            });
          }
          if (crdt.deleted) {
            Meteor.log["throw"]('crdt.tryingToDeleteCrdtTwice', {
              collection: _this._name,
              crdtId: crdtId
            });
          }
          _this._crdts.update({
            _id: crdt.id
          }, {
            $set: {
              _deleted: true,
              _clock: clock
            }
          });
          _this._updatedCrdts.push(crdt.id);
          return crdtId;
        },
        insertProperty: function(crdtId, args, clock, site) {
          var changedProps, crdt, index, position;
          console.assert(_this._txRunning(), 'Trying to execute operation "insertProperty" outside a transaction.');
          crdt = _this._getCrdt(crdtId);
          if (crdt == null) {
            Meteor.log["throw"]('crdt.tryingToInsertValueIntoNonexistentCrdt', {
              key: args.key,
              collection: _this._name,
              crdtId: crdtId
            });
          }
          index = _this._getCurrentIndex(crdt, args.key);
          position = crdt.insertAtIndex(args.key, args.value, index, site);
          changedProps = {
            _clock: clock
          };
          changedProps[args.key] = crdt.serialize()[args.key];
          _this._crdts.update({
            _id: crdt.id
          }, {
            $set: changedProps
          });
          _this._updatedCrdts.push(crdt.id);
          return position;
        },
        removeProperty: function(crdtId, args, clock, site) {
          var changedProps, crdt, deletedIndices, locator;
          locator = null;
          if (args.locator != null) {
            locator = args.locator;
          }
          console.assert(_this._txRunning(), 'Trying to execute operation "removeProperty" outside a transaction.');
          crdt = _this._getCrdt(crdtId);
          if (crdt == null) {
            Meteor.log["throw"]('crdt.tryingToDeleteValueFromNonexistentCrdt', {
              key: args.key,
              locator: locator,
              collection: _this._name,
              crdtId: crdtId
            });
          }
          deletedIndices = crdt["delete"](args.key, locator);
          changedProps = {
            _clock: clock
          };
          changedProps[args.key] = crdt.serialize()[args.key];
          _this._crdts.update({
            _id: crdt.id
          }, {
            $set: changedProps
          });
          _this._updatedCrdts.push(crdt.id);
          return deletedIndices;
        },
        inverse: function(crdtId, args, clock, site) {
          var changedProps, crdt, deletedIndex, origArgs, origChange, origIndex, origOp, origResult, origSite, undeletedIndices;
          origOp = args.op, origArgs = args.args, origResult = args.result;
          switch (origOp) {
            case 'insertObject':
              return _this._ops.removeObject(crdtId, {}, clock, site);
            case 'removeObject':
              console.assert(_this._txRunning(), 'Trying to execute operation ' + '"inverse(removeObject)" outside a transaction.');
              crdt = _this._getCrdt(crdtId);
              if (crdt == null) {
                Meteor.log["throw"]('crdt.tryingToUndeleteNonexistentCrdt', {
                  collection: _this._name,
                  crdtId: crdtId
                });
              }
              if (!crdt.deleted) {
                Meteor.log.warning('crdt.tryingToUndeleteVisibleCrdt', {
                  collection: _this._name,
                  crdtId: crdtId
                });
              }
              _this._crdts.update({
                _id: crdt.id
              }, {
                $set: {
                  _deleted: false,
                  _clock: clock
                }
              });
              _this._updatedCrdts.push(crdt.id);
              return true;
            case 'insertProperty':
              console.assert(_this._txRunning(), 'Trying to execute operation ' + '"inverse(insertProperty)" outside a transaction.');
              crdt = _this._getCrdt(crdtId);
              if (crdt == null) {
                Meteor.log["throw"]('crdt.tryingToDeleteValueFromNonexistentCrdt', {
                  key: origArgs.key,
                  locator: origResult,
                  collection: _this._name,
                  crdtId: crdtId
                });
              }
              origIndex = origResult[0], origSite = origResult[1], origChange = origResult[2];
              deletedIndex = crdt.deleteIndex(origArgs.key, origIndex, origSite, origChange);
              changedProps = {
                _clock: clock
              };
              changedProps[origArgs.key] = crdt.serialize()[origArgs.key];
              _this._crdts.update({
                _id: crdt.id
              }, {
                $set: changedProps
              });
              _this._updatedCrdts.push(crdt.id);
              return deletedIndex;
            case 'removeProperty':
              console.assert(_this._txRunning(), 'Trying to execute operation ' + '"inverse(removeProperty)" outside a transaction.');
              crdt = _this._getCrdt(crdtId);
              if (crdt == null) {
                Meteor.log["throw"]('crdt.tryingToUndeleteValueFromNonexistentCrdt', {
                  key: origArgs.key,
                  locator: origResult[0],
                  collection: _this._name,
                  crdtId: crdtId
                });
              }
              undeletedIndices = (function() {
                var _i, _len, _ref, _results;
                _results = [];
                for (_i = 0, _len = origResult.length; _i < _len; _i++) {
                  _ref = origResult[_i], origIndex = _ref[0], origSite = _ref[1], origChange = _ref[2];
                  _results.push(crdt.undeleteIndex(origArgs.key, origIndex, origSite, origChange));
                }
                return _results;
              })();
              changedProps = {
                _clock: clock
              };
              changedProps[origArgs.key] = crdt.serialize()[origArgs.key];
              _this._crdts.update({
                _id: crdt.id
              }, {
                $set: changedProps
              });
              _this._updatedCrdts.push(crdt.id);
              return undeletedIndices;
            default:
              return Meteor.log["throw"]('crdt.cannotInvert', {
                op: origOp
              });
          }
        }
      };
    };

    return Collection;

  })(OriginalCollection);

  if (Meteor.isServer) {
    Meteor.Collection.prototype.reset = function() {
      this.remove({});
      if (this._versioned) {
        this._crdts.remove({});
      }
      return true;
    };
    OriginalLivedataSubscription = Meteor._LivedataSubscription;
    Meteor._LivedataSubscription = (function(_super) {

      __extends(_LivedataSubscription, _super);

      function _LivedataSubscription() {
        return _LivedataSubscription.__super__.constructor.apply(this, arguments);
      }

      _LivedataSubscription.prototype._removingAllDocs = false;

      _LivedataSubscription.prototype._synchronizeCrdt = function(collectionName, id, fields) {
        var added, changedKeys, coll, collView, crdtFields, crdtKey, crdtKeys, crdtSnapshot, currentCrdt, docView, internalKeys, publishedKeys, strId, _i, _len, _ref;
        if (fields == null) {
          fields = {};
        }
        coll = Meteor.tx._getCollection(collectionName);
        if (coll == null) {
          return;
        }
        currentCrdt = (_ref = coll._crdts.findOne({
          _crdtId: id
        })) != null ? _ref : {};
        if (currentCrdt == null) {
          console.assert(false, 'Found snapshot without corresponding CRDT');
          return;
        }
        internalKeys = ['_id', '_crdtId', '_clock', '_deleted'];
        changedKeys = _.keys(fields);
        strId = this._idFilter.idStringify(currentCrdt._id);
        collView = this._session.collectionViews[coll._crdts._name];
        if (collView != null) {
          docView = collView.documents[strId];
        }
        added = docView ? false : true;
        crdtSnapshot = added ? {} : docView.getFields();
        publishedKeys = _.keys(crdtSnapshot);
        crdtKeys = _.union(internalKeys, changedKeys, publishedKeys);
        crdtFields = {};
        for (_i = 0, _len = crdtKeys.length; _i < _len; _i++) {
          crdtKey = crdtKeys[_i];
          if (!_.isEqual(currentCrdt[crdtKey], crdtSnapshot[crdtKey])) {
            crdtFields[crdtKey] = currentCrdt[crdtKey];
          }
        }
        return [coll._crdts._name, currentCrdt._id, crdtFields, added];
      };

      _LivedataSubscription.prototype.added = function(collectionName, id, fields) {
        var added, crdtColl, crdtFields, crdtId, crdtSync;
        crdtSync = this._synchronizeCrdt(collectionName, id, fields);
        if (_.isArray(crdtSync)) {
          crdtColl = crdtSync[0], crdtId = crdtSync[1], crdtFields = crdtSync[2], added = crdtSync[3];
          if (added) {
            _LivedataSubscription.__super__.added.call(this, crdtColl, crdtId, crdtFields);
          } else {
            this.changed(crdtColl, crdtId, crdtFields, false);
          }
        }
        return _LivedataSubscription.__super__.added.call(this, collectionName, id, fields);
      };

      _LivedataSubscription.prototype.changed = function(collectionName, id, fields, syncCrdt) {
        var added, crdtColl, crdtFields, crdtId, crdtSync;
        if (syncCrdt == null) {
          syncCrdt = true;
        }
        if (syncCrdt) {
          crdtSync = this._synchronizeCrdt(collectionName, id, fields);
          if (_.isArray(crdtSync)) {
            crdtColl = crdtSync[0], crdtId = crdtSync[1], crdtFields = crdtSync[2], added = crdtSync[3];
            console.assert(!added, 'Trying to update a non-existent CRDT');
            _LivedataSubscription.__super__.changed.call(this, crdtColl, crdtId, crdtFields);
          }
        }
        return _LivedataSubscription.__super__.changed.call(this, collectionName, id, fields);
      };

      _LivedataSubscription.prototype.removed = function(collectionName, id) {
        var added, crdt, crdtColl, crdtFields, crdtId, crdtSync, isCrdtColl, snapshotCollName, snapshotId, strId;
        isCrdtColl = /_\w+Crdts/.test(collectionName);
        console.assert(!isCrdtColl || this._removingAllDocs);
        if (isCrdtColl) {
          strId = this._idFilter.idStringify(id);
          crdt = this._session.collectionViews[collectionName].documents[strId].getFields();
          snapshotId = this._idFilter.idStringify(crdt._crdtId);
          snapshotCollName = collectionName.replace(/^_(\w+)Crdts/, '$1');
          if (this._documents[snapshotCollName][snapshotId] != null) {
            return;
          }
        }
        if (!this._removingAllDocs) {
          crdtSync = this._synchronizeCrdt(collectionName, id);
          if (_.isArray(crdtSync)) {
            crdtColl = crdtSync[0], crdtId = crdtSync[1], crdtFields = crdtSync[2], added = crdtSync[3];
            console.assert(!added, 'Trying to delete a non-existent CRDT');
            this.changed(crdtColl, crdtId, crdtFields, false);
          }
        }
        return _LivedataSubscription.__super__.removed.call(this, collectionName, id);
      };

      _LivedataSubscription.prototype._removeAllDocuments = function() {
        this._removingAllDocs = true;
        return _LivedataSubscription.__super__._removeAllDocuments.call(this);
      };

      return _LivedataSubscription;

    })(OriginalLivedataSubscription);
  }

}).call(this);
